



# synchronized原理

## 怎么使用synchronized

- 修饰方法
- 修饰代码块

​	共同点：需要使用一个对象作为锁

- 修饰静态方法时，充当锁的对象是类对象
- 对象实例方法是，充当锁的对象是实例对象
- 修饰代码块的时候，充当锁的对象是你提供的Object对象

## 为什么需要提供这样一个对象

在不同的锁的等级状态下，对象头Mrak Work的内容是不同的，即State（状态）不同，如下。这样的设计让**synchronized**的**效率得到了很大提升**（1.6）

```apl
|--------------------------------------------------------------------|--------------------|
|                       Mark Word (64 bits)                          |       State        |
|--------------------------------------------------------------------|--------------------|
|  unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0 | 01   |       Normal       |   
|--------------------------------------------------------------------|--------------------|
|  thread:54 |  epoch:2    | unused:1 | age:4 | biased_lock:1 | 01   |       Biased       |   偏向
|--------------------------------------------------------------------|--------------------|
|                     ptr_to_lock_record:62                   | 00   | Lightweight Locked |   轻量级锁
|--------------------------------------------------------------------|--------------------|
|                     ptr_to_heavyweight_monitor:62           | 10   | Heavyweight Locked |   重量级锁
|--------------------------------------------------------------------|--------------------|
|                                                             | 11   |   Marked for GC    |
|--------------------------------------------------------------------|--------------------|
```

在偏向锁开启的时候（默认就是开启），初始化对象时状态头为Biased状态。在调用hashcode()方法时会转换成Norma状态。（还有其他操作能够消除偏向）

## synchronized基础知识

## 锁升级的过程

**偏向锁 -> 轻量级锁 -> 重量级锁**

在正式熟悉锁升级的过程前，先分别了解一下三个锁的基本知识。

### 1、偏向锁：

Java 6 中引入了偏向锁来做进一步优化：<font color = blue>只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头</font>，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有

#### 1.1、测试偏向锁

在偏向锁开启的时候（默认就是开启），新建对象的状态为偏向101，对象头的其他内容均为0，在被作为synchronized（没有其他线程使用，竞争该对象）是该对象会偏向当前线程

☆     查看不同状态下的信息，演示代码如下（来源于黑马程序员文档）

```java
// 添加虚拟机参数 -XX:BiasedLockingStartupDelay=0 
public static void main(String[] args) throws IOException {
 	Dog d = new Dog();
	ClassLayout classLayout = ClassLayout.parseInstance(d);
 	new Thread(() -> {
 		log.debug("synchronized 前");
 		System.out.println(classLayout.toPrintableSimple(true));
 		synchronized (d) {
 			log.debug("synchronized 中");
			 System.out.println(classLayout.toPrintableSimple(true));
		}
		log.debug("synchronized 后");
 		System.out.println(classLayout.toPrintableSimple(true));
	}, "t1").start();
```

☆     运行结果

```
输出
11:08:58.117 c.TestBiased [t1] - synchronized 前
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 
11:08:58.121 c.TestBiased [t1] - synchronized 中
00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 
11:08:58.121 c.TestBiased [t1] - synchronized 后
00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 
```

**可以看到synchronized 前，表示了默认是开启使用了偏向锁的，只是当前没有确定偏向于哪一个对象，随后偏向了一个线程，在退出synchonized代码块的时候<font color = 'red'>仍然偏向这个线程！</font>**

### 1.2、撤销偏向

- 方式一、调用对象hashcode()方法，再看一下对象头的格式，线程占用了太多的bits，没有位置存在hashcode，这个时候状态从偏向转换成normal
- 方式二、其他线程使用、竞争该对象时。
  - 其他线程使用该对象（加锁使用），会将偏向锁升级为轻量级锁（并未全部如此，其中还涉及批量重偏向，批量撤销）
  - 其他线程竞争该对象，最终锁状态势必成为重量级锁
- 方式三、调用wait\notify方法
  - wait/notify只有重量锁有，所以不管你是轻量级还是偏向锁我都会将你从你当前锁的状态膨胀到重量级锁（除非你本来就是重量级锁）
- 方式四、调用park、unpark方法，同上

### 1.3、批量重偏向

注意：批量的意思

当某一类的多个类实例虽然被多个线程访问，但是没有发生竞争，如开始时类实例偏向t1线程，我们在前面知道了其他线程使用该实例对线的时候会锁升级成为轻量级锁，最后释放锁变成无锁状态。这种情况发生的撤销偏向发生了20次就会将后面的这些类实例对象重偏向t2线程。（注意是后面的这些实例对象）

### 1.4、批量撤销

当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的对象也是不可偏向的

## 2、轻量级锁

- 从Mark Word 头可以看出，轻量级锁的时候，对象头是`ptr_to_lock_record`占62bits，最后两位00。

- 如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。



- 创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word

- **让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录**
- **如果CAS 替换失败则说明当前时间锁对象已被某个线程占有，那么此时当前线程只有通过自旋的方式去获取锁。如果在<font color = red>自旋一定次数后仍未获得锁</font>，那么轻量级锁将会升级成重量级锁。**

## 3、重量级锁

Object 对象拥有一个Monitor 锁，让 Object 指向重量级锁地址（具体见文档）

- 自旋优化
- 字节码文件，见文档

### 从无锁到重量级锁的流程

![image-20210817225749373](https://img2020.cnblogs.com/blog/1663830/202103/1663830-20210306145103163-2101171780.png)

### 三种锁的优缺点



![image-20210817225749373](C:\Users\VULCAN\AppData\Roaming\Typora\typora-user-images\image-20210817225749373.png)

在1.7的时候，自旋锁默认启用，自旋次数由JVM决定。

**重量级锁**：在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 Java 7 之后不能控制是否开启自旋功能

### 三种锁hashcode的记录

**偏向锁不记录hashcode**，没有空间存放，如果对象调用了hashcode方法，将从偏向状态到无锁状态

轻量级锁在锁记录（每个线程都有锁记录对象）中记录hashcode（交换而来），而这个时候object记录的是锁记录地址

重量级锁在monitor中记录hashcode，同样是交换而来，而这个时候object对象记录的是monitor地址

参考博客等：

- ​	[JOL：分析Java对象的内存布局 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/151856103)
- ​    [轻量级锁 - 茁壮成长的菜鸡 - 博客园 (cnblogs.com)](https://www.cnblogs.com/lch-Hao/p/14490685.html)



